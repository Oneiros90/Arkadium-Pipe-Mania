import{l as a,D as l,k as g,G as f,A as m,C as c,b as C,f as w,R as y,c as P,m as u,L as S,a as p,d as v}from"./GridRenderer-BJLz8noh.js";class G{seed;constructor(e=Date.now()){this.seed=e}getSeed(){return this.seed}setSeed(e){this.seed=e}next(){return this.seed=(this.seed*9301+49297)%233280,this.seed/233280}nextInt(e,t){return Math.floor(this.next()*(t-e+1))+e}nextFloat(e,t){return this.next()*(t-e)+e}choice(e){return e[this.nextInt(0,e.length-1)]}shuffle(e){const t=[...e];for(let i=t.length-1;i>0;i--){const n=this.nextInt(0,i);[t[i],t[n]]=[t[n],t[i]]}return t}}class R{constructor(e,t,i){this.grid=e,this.random=t,this.config=i}initialize(){this.placeBlockedCells();const e=this.selectStartPosition();return this.grid.setStart(e),a.info("GridInitializer","Grid initialized",{startPosition:e,gridSize:`${this.grid.width}x${this.grid.height}`}),e}placeBlockedCells(){const e=this.grid.width*this.grid.height,t=Math.floor(e*this.config.gameplay.blockRatio);let i=0;for(;i<t;){const n=this.random.nextInt(0,this.grid.height-1),s=this.random.nextInt(0,this.grid.width-1),r=this.grid.getCell({row:n,col:s});r&&r.isEmpty&&(this.grid.setBlocked({row:n,col:s}),i++)}a.debug("GridInitializer",`Placed ${i} blocked cells`)}selectStartPosition(){const e=this.grid.height-2;for(;;){const t=this.random.nextInt(0,e),i=this.random.nextInt(0,this.grid.width-1),n=this.grid.getCell({row:t,col:i}),s=this.grid.getNeighbor({row:t,col:i},l.South);if(n&&n.isEmpty&&s&&!s.isBlocked)return{row:t,col:i}}}}class z{constructor(e,t){this.random=e,this.initializeWeights(t)}weights=new Map;totalWeight=0;initializeWeights(e){e.forEach(t=>{g.has(t.type)?(this.weights.set(t.type,t.weight),this.totalWeight+=t.weight):a.warn("PipeFactory",`Skipping unknown pipe type in config: ${t.type}`)}),a.debug("PipeFactory","Initialized pipe weights",{weights:Object.fromEntries(this.weights),totalWeight:this.totalWeight})}createRandomPipe(){const e=this.selectRandomType();return this.createPipe(e)}selectRandomType(){let e=this.random.nextFloat(0,this.totalWeight);for(const[i,n]of this.weights.entries())if(e-=n,e<=0)return i;const t=g.getRegisteredTypes();if(t.length>0)return t[0];throw new Error("No pipes registered in PipeRegistry")}createPipe(e){try{return g.createRandom(e,this.random)}catch(t){a.error("PipeFactory",`Failed to create pipe of type ${e}`,t);const i=g.getRegisteredTypes();if(i.length>0)return g.createRandom(i[0],this.random);throw t}}}class D{constructor(e){this.grid=e}isValidConnection(e,t,i){if(!e.hasPipe()||!t.hasPipe())return!1;const n=e.pipe,s=t.pipe,r=this.grid.getOppositeDirection(i);return n.hasConnection(i)&&s.hasConnection(r)}findConnectedPath(e){const t=[],i=new Set,n=this.grid.getCell(e);if(!n)return t;let s=n,r=null;for(;s;){const h=`${s.position.row}-${s.position.col}`;if(i.has(h)||(i.add(h),t.push(s),!s.hasPipe()&&!s.isStart))break;const d=this.findNextCell(s,r);if(!d)break;r=d.direction,s=d.cell}return a.debug("PathValidator",`Found path of length ${t.length}`,{startPosition:e}),t}findNextCell(e,t){const i=[l.North,l.East,l.South,l.West];for(const n of i){if(t&&n===this.grid.getOppositeDirection(t))continue;const s=this.grid.getNeighbor(e.position,n);if(s){if(e.isStart){if(s.hasPipe()){const r=this.grid.getOppositeDirection(n);if(s.pipe.hasConnection(r))return{cell:s,direction:n}}}else if(e.hasPipe()&&e.pipe.getExitDirection(t)===n&&this.isValidConnection(e,s,n))return{cell:s,direction:n}}}return null}getPathLength(e){return this.findConnectedPath(e).length}getStartCell(e){return this.grid.getCell(e)}getNextCell(e){const t=this.grid.getCell(e);if(!t)return null;const i=[l.North,l.East,l.South,l.West];for(const n of i){const s=this.grid.getNeighbor(e,n);if(!s)continue;const r=this.grid.getOppositeDirection(n);if(!(s.hasWater&&s.waterFlows.length>0&&!s.canEnterFromDirection(r)&&s.waterFlows.every(d=>d.level>=1))){if(t.isStart){if(s.hasPipe()&&s.canEnterFromDirection(r)&&s.pipe.hasConnection(r))return{cell:s,entryDirection:r}}else if(t.hasPipe()&&t.waterFlows.length>0){const h=t.waterFlows[t.waterFlows.length-1];if(t.pipe.getExitDirection(h.entryDirection)===n&&s.hasPipe()&&s.canEnterFromDirection(r)&&s.pipe.hasConnection(r))return{cell:s,entryDirection:r}}}}return null}}class F{constructor(e,t,i,n){this.validator=e,this.config=t,this.onCellUpdate=i,this.onGameEnd=n}state="idle";currentCell=null;currentCellProgress=0;currentEntryDirection=null;completedCells=0;start(e){this.completedCells=0,this.state="flowing",this.currentCell=this.validator.getStartCell(e),this.advanceToNextCell(),a.info("FlowSystem","Water flow started",{startPosition:e})}update(e){if(this.state!=="flowing"||!this.currentCell||!this.currentEntryDirection)return;const t=this.config.gameplay.flowSpeed;this.currentCellProgress+=e*t,this.currentCell.setWaterLevel(this.currentCellProgress,this.currentEntryDirection),this.onCellUpdate(this.currentCell.position.row,this.currentCell.position.col),this.currentCellProgress>=1&&this.advanceToNextCell()}advanceToNextCell(){if(!this.currentCell){this.handleFlowEnd();return}if(this.currentCell.hasPipe()&&this.currentEntryDirection){this.currentCell.fillWithWater(),this.currentCell.markDirectionUsed(this.currentEntryDirection);const t=this.currentCell.pipe.getExitDirection(this.currentEntryDirection);t&&this.currentCell.markDirectionUsed(t)}const e=this.validator.getNextCell(this.currentCell.position);if(!e){this.handleFlowEnd();return}this.currentCell=e.cell,this.currentEntryDirection=e.entryDirection,this.currentCellProgress=0,this.completedCells++}handleFlowEnd(){this.state="end",a.info("FlowSystem","Flow ended",{completedCells:this.completedCells}),this.onGameEnd(this.completedCells)}getState(){return this.state}reset(){this.state="idle",this.currentCell=null,this.currentEntryDirection=null,this.currentCellProgress=0,this.completedCells=0}isActive(){return this.state==="flowing"}}class x{constructor(e,t,i,n,s){this.config=e,this.visualConfig=t,this.onCellUpdate=i,this.onQueueUpdate=n,this.onGameEnd=s,this.grid=new f(e.grid.width,e.grid.height),this.random=new G(e.seed),this.pipeFactory=new z(this.random,e.pipes),this.gridInitializer=new R(this.grid,this.random,e),this.pathValidator=new D(this.grid),this.flowSystem=new F(this.pathValidator,e,this.handleCellFilled.bind(this),this.handleGameEnd.bind(this)),a.info("GameState","Game initialized",{seed:this.random.getSeed()})}grid;random;pipeFactory;gridInitializer;pathValidator;flowSystem;startPosition;pipeQueue=[];requiredPathLength=0;gameTimer=0;timerRunning=!1;start(){this.startPosition=this.gridInitializer.initialize(),this.requiredPathLength=this.random.nextInt(this.config.gameplay.minPathLength.min,this.config.gameplay.minPathLength.max),this.fillPipeQueue(),this.notifyGridUpdate(),a.info("GameState","Game started",{startPosition:this.startPosition,requiredPathLength:this.requiredPathLength})}fillPipeQueue(){this.pipeQueue=[];for(let e=0;e<this.visualConfig.grid.queueSize;e++)this.pipeQueue.push(this.pipeFactory.createRandomPipe());this.onQueueUpdate(this.pipeQueue)}update(e){this.timerRunning&&(this.gameTimer+=e,this.gameTimer>=this.config.gameplay.placementDelay&&!this.flowSystem.isActive()&&this.startWaterFlow()),this.flowSystem.isActive()&&this.flowSystem.update(e)}startWaterFlow(){a.info("GameState","Starting water flow",{gameTimer:this.gameTimer,placementDelay:this.config.gameplay.placementDelay}),this.flowSystem.start(this.startPosition)}handleCellClick(e,t){const i={row:e,col:t},n=this.grid.getCell(i);if(!n||!n.canPlacePipe())return;const s=this.pipeQueue.shift();s&&(this.grid.placePipe(i,s),this.onCellUpdate(e,t),this.pipeQueue.push(this.pipeFactory.createRandomPipe()),this.onQueueUpdate(this.pipeQueue),a.debug("GameState","Pipe placed",{position:i,pipeType:s.type}),this.timerRunning||this.startGameTimer())}startGameTimer(){this.timerRunning=!0,this.gameTimer=0,a.info("GameState","Game timer started")}handleCellFilled(e,t){this.onCellUpdate(e,t)}handleGameEnd(e){this.timerRunning=!1;const t=e>=this.requiredPathLength;this.onGameEnd(t,e,this.requiredPathLength)}getGrid(){return this.grid}getRequiredPathLength(){return this.requiredPathLength}getCurrentPathLength(){return this.pathValidator.getPathLength(this.startPosition)-1}reset(){this.grid.reset(),this.flowSystem.reset(),this.pipeQueue=[],this.gameTimer=0,this.timerRunning=!1,this.start()}notifyGridUpdate(){this.grid.forEachCell(e=>{this.onCellUpdate(e.position.row,e.position.col)})}}class E{constructor(e,t,i){this.container=e,this.config=t,this.visualConfig=i,this.app=new m,this.gridContainer=new c,this.queueContainer=new c,this.uiContainer=new c,this.assetManager=new C}app;gridContainer;queueContainer;uiContainer;assetManager;async initialize(){const e=w(this.visualConfig.assets);await this.assetManager.loadAssets(e);const t=this.config.grid.width*this.visualConfig.grid.cellSize+this.visualConfig.grid.padding*2,i=this.config.grid.height*this.visualConfig.grid.cellSize+this.visualConfig.grid.padding*2,n=this.visualConfig.queue.gap,s=t+n+this.visualConfig.grid.cellSize;await this.app.init({width:s,height:i,backgroundColor:this.visualConfig.canvas.backgroundColor,antialias:!0,resolution:window.devicePixelRatio||1,autoDensity:!0}),this.container.appendChild(this.app.canvas),this.gridContainer.x=this.visualConfig.grid.padding,this.gridContainer.y=this.visualConfig.grid.padding,this.queueContainer.x=t+n,this.queueContainer.y=this.visualConfig.grid.padding,this.app.stage.addChild(this.gridContainer),this.app.stage.addChild(this.queueContainer),this.app.stage.addChild(this.uiContainer),this.drawGridBackground(),this.gridContainer.hitArea=new y(0,0,t,i),a.info("GameRenderer","Grid container initialized with hitArea",{width:t,height:i})}drawGridBackground(){const e=new P;e.rect(0,0,this.config.grid.width*this.visualConfig.grid.cellSize,this.config.grid.height*this.visualConfig.grid.cellSize),e.fill(2763306),this.gridContainer.addChild(e)}getGridContainer(){return this.gridContainer}getQueueContainer(){return this.queueContainer}getUIContainer(){return this.uiContainer}getCellSize(){return this.visualConfig.grid.cellSize}getAssetManager(){return this.assetManager}destroy(){this.app.destroy(!0)}}class b{constructor(e,t,i){this.container=e,this.visualConfig=t,this.assetManager=i}queueGraphics=[];render(e){this.clear(),a.info("QueueRenderer",`Rendering queue with ${e.length} pipes`);const t=(e.length-1)*(this.visualConfig.grid.cellSize+this.visualConfig.queue.gap);e.forEach((i,n)=>{const s=new c;s.y=t-n*(this.visualConfig.grid.cellSize+this.visualConfig.queue.gap),s.alpha=n===0?1:this.visualConfig.queue.alpha;const r=new u(this.assetManager.getTexture(this.visualConfig.assets.pipes.background));r.width=this.visualConfig.grid.cellSize,r.height=this.visualConfig.grid.cellSize,s.addChild(r);const h=this.getPipeSprite(i);s.addChild(h),this.container.addChild(s),this.queueGraphics.push(s)})}getPipeSprite(e){const t=e.getTexturePath(this.visualConfig),i=new u(this.assetManager.getTexture(t));return i.width=this.visualConfig.grid.cellSize,i.height=this.visualConfig.grid.cellSize,i.anchor.set(.5),i.x=this.visualConfig.grid.cellSize/2,i.y=this.visualConfig.grid.cellSize/2,i.angle=e.rotation,i}clear(){this.queueGraphics.forEach(e=>e.destroy()),this.queueGraphics=[]}}class k{gameState;gameRenderer;gridRenderer;queueRenderer;lastTime=0;async initialize(){a.setMinLevel(S.Debug),a.info("Game","Initializing game...");const e=await p.loadFromFile("/config/game.yaml"),t=await p.loadVisualConfig(`/config/visual-${e.theme}.yaml`),i=document.getElementById("game-container");if(!i)throw new Error("Game container not found");this.gameRenderer=new E(i,e,t),await this.gameRenderer.initialize(),this.gameState=new x(e,t,this.handleCellUpdate.bind(this),this.handleQueueUpdate.bind(this),this.handleGameEnd.bind(this)),this.gridRenderer=new v(this.gameRenderer.getGridContainer(),this.gameState.getGrid(),t,this.gameRenderer.getAssetManager()),this.queueRenderer=new b(this.gameRenderer.getQueueContainer(),t,this.gameRenderer.getAssetManager()),this.setupClickHandler(),this.gameState.start(),this.gridRenderer.initialize(),this.lastTime=performance.now(),this.gameLoop(this.lastTime),a.info("Game","Game initialized successfully")}setupClickHandler(){const e=this.gameRenderer.getGridContainer(),t=this.gameRenderer.getCellSize();e.eventMode="static",e.on("pointerdown",i=>{const n=i.getLocalPosition(e),s=Math.floor(n.x/t),r=Math.floor(n.y/t);this.gameState.handleCellClick(r,s)})}handleCellUpdate(e,t){this.gridRenderer.updateCell(e,t)}handleQueueUpdate(e){a.info("Game","Queue update received",{length:e.length}),this.queueRenderer.render(e)}handleGameEnd(e,t,i){a.info("Game",`Game ended: ${e?"Victory":"Defeat"}`,{pathLength:t,requiredLength:i}),setTimeout(()=>{alert(e?`You won! Path length: ${t}/${i}`:`You lost! Path length: ${t}/${i}`),this.gameState.reset(),this.gridRenderer.initialize()},500)}gameLoop(e){const t=(e-this.lastTime)/1e3;this.lastTime=e,this.gameState.update(t),requestAnimationFrame(i=>this.gameLoop(i))}}const T=new k;T.initialize().catch(o=>{a.error("Game","Failed to initialize game",o),console.error(o)});
